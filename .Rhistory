B <- read.csv("data/tblAkv3x3.csv", header = FALSE)
N <- 3
#Introduzca la memoria, recuerde que la memoria minima debe permitir hacer una operacion,
# es decir tomar por lo menos un valor de la matriz y un valor del vector, y poder guardar
# el resultado.
#************************************************************************
memoria <- 5664
#************************************************************************
if (memoria > memory.limit()){
print("La maquina no posee tanta memoria, por lo tanto no se puede realizar las operaciones
con esta cantidad de memoria.")
}
#Minmemoria <- Una fila de la matriz  + Una columna de la matriz    + El maximo resultado de una multiplicacion n veces
minmemoria <- object.size(A[N,])*N + object.size(B[N,])*N + (object.size(max(A[,ncol(A)]) * max(B[,ncol(B)])))*N
memoria <- memlimit(memoria)
if (memoria < minmemoria){
print("No hay suficiente memoria para realizar una operacion")
}
#*********************************************************************************
#Calculamos cuantas operaciones podemos hacer utilizando la memoria indicada.
#*********************************************************************************
chunks <- function(A, x, N, chunksF, indice){
#********************************************************
#Division de chunks utilizando la memoria.
#********************************************************
#tamres es el tamano necesario para guardar un resultado.
tamres <- (object.size(max(A[,ncol(A)]) * max(B[,ncol(B)])))*N
#tamcol es el size de un valor del vector.
tamcol <- object.size(B[N,])*N
#Acumula la cantidad de memoria que se puede utilizar
acum <- 0
#Cuenta cuantas operaciones se pueden hacer
cont <- 0
for (i in indice:((indice + chunksF)-1)) {
acum <- object.size(A[i,])*N  + tamres  + tamcol + acum
print(acum)
if (acum > memoria){
break
}
#Cuento cuantos valores  puedo utilizar.
cont <- cont + 1
}
return(cont)
}
#Llamo a la funcion chunks que me dice cuantas operaciones puedo realizar.
indice <- 1
j <- 1
cont <- chunks(A, x, N, chunksF, 1)
cont
memoria <- 5664 + 5664
cont <- chunks(A, x, N, chunksF, 1)
cont
memoria <- 5664 + 5664 + 5664
cont <- chunks(A, x, N, chunksF, 1)
cont
memoria <- 5664 + 5664 + 5664 + 5664
cont <- chunks(A, x, N, chunksF, 1)
cont
A
A <- read.csv("data/tblAkv3x3.csv", header = FALSE)
B <- read.csv("data/tblAkv3x3.csv", header = FALSE)
N <- 3
#Introduzca la memoria, recuerde que la memoria minima debe permitir hacer una operacion,
# es decir tomar por lo menos un valor de la matriz y un valor del vector, y poder guardar
# el resultado.
#************************************************************************
memoria <- 5664
#************************************************************************
if (memoria > memory.limit()){
print("La maquina no posee tanta memoria, por lo tanto no se puede realizar las operaciones
con esta cantidad de memoria.")
}
#Minmemoria <- Una fila de la matriz  + Una columna de la matriz    + El maximo resultado de una multiplicacion n veces
minmemoria <- object.size(A[N,])*N + object.size(B[N,])*N + (object.size(max(A[,ncol(A)]) * max(B[,ncol(B)])))*N
memoria <- memlimit(memoria)
if (memoria < minmemoria){
print("No hay suficiente memoria para realizar una operacion")
}
#Llamo a producmv
resultadomm <- productmm(A, B, N, memoria)
cat("El resultado de A*B 3x3 con memoria es: " )
resultadomm
source("src/memlimit.R")
A <- read.csv("data/tblAkv3x3.csv", header = FALSE)
B <- read.csv("data/tblAkv3x3.csv", header = FALSE)
N <- 3
#Introduzca la memoria, recuerde que la memoria minima debe permitir hacer una operacion,
# es decir tomar por lo menos un valor de la matriz y un valor del vector, y poder guardar
# el resultado.
#************************************************************************
memoria <- 5664
#************************************************************************
if (memoria > memory.limit()){
print("La maquina no posee tanta memoria, por lo tanto no se puede realizar las operaciones
con esta cantidad de memoria.")
}
#Minmemoria <- Una fila de la matriz  + Una columna de la matriz    + El maximo resultado de una multiplicacion n veces
minmemoria <- object.size(A[N,])*N + object.size(B[N,])*N + (object.size(max(A[,ncol(A)]) * max(B[,ncol(B)])))*N
memoria <- memlimit(memoria)
if (memoria < minmemoria){
print("No hay suficiente memoria para realizar una operacion")
}
#Llamo a producmv
resultadomm <- productmm(A, B, N, memoria)
cat("El resultado de A*B 3x3 con memoria es: " )
resultadomm
#Borro el archivo temporal.
unlink(paste(direccion,"/tmp/archivotemporal.csv", sep = ""))
source("src/productmm.R")
A <- read.csv("data/tblAkv3x3.csv", header = FALSE)
B <- read.csv("data/tblAkv3x3.csv", header = FALSE)
N <- 3
#Introduzca la memoria, recuerde que la memoria minima debe permitir hacer una operacion,
# es decir tomar por lo menos un valor de la matriz y un valor del vector, y poder guardar
# el resultado.
#************************************************************************
memoria <- 5664
#************************************************************************
if (memoria > memory.limit()){
print("La maquina no posee tanta memoria, por lo tanto no se puede realizar las operaciones
con esta cantidad de memoria.")
}
#Minmemoria <- Una fila de la matriz  + Una columna de la matriz    + El maximo resultado de una multiplicacion n veces
minmemoria <- object.size(A[N,])*N + object.size(B[N,])*N + (object.size(max(A[,ncol(A)]) * max(B[,ncol(B)])))*N
memoria <- memlimit(memoria)
if (memoria < minmemoria){
print("No hay suficiente memoria para realizar una operacion")
}
#Llamo a producmv
resultadomm <- productmm(A, B, N, memoria)
cat("El resultado de A*B 3x3 con memoria es: " )
resultadomm
#Borro el archivo temporal.
unlink(paste(direccion,"/tmp/archivotemporal.csv", sep = ""))
A <- read.csv("data/tblAkv3x3.csv", header = FALSE)
B <- read.csv("data/tblAkv3x3.csv", header = FALSE)
N <- 3
#Introduzca la memoria, recuerde que la memoria minima debe permitir hacer una operacion,
# es decir tomar por lo menos un valor de la matriz y un valor del vector, y poder guardar
# el resultado.
#************************************************************************
memoria <- 5664
#************************************************************************
if (memoria > memory.limit()){
print("La maquina no posee tanta memoria, por lo tanto no se puede realizar las operaciones
con esta cantidad de memoria.")
}
#Minmemoria <- Una fila de la matriz  + Una columna de la matriz    + El maximo resultado de una multiplicacion n veces
minmemoria <- object.size(A[N,])*N + object.size(B[N,])*N + (object.size(max(A[,ncol(A)]) * max(B[,ncol(B)])))*N
memoria <- memlimit(memoria)
if (memoria < minmemoria){
print("No hay suficiente memoria para realizar una operacion")
}
#Llamo a producmv
resultadomm <- productmm(A, B, N, memoria)
cat("El resultado de A*B 3x3 con memoria es: " )
resultadomm
#Borro el archivo temporal.
unlink(paste(direccion,"/tmp/archivotemporal.csv", sep = ""))
source("src/productmm.R")
A <- read.csv("data/tblAkv3x3.csv", header = FALSE)
B <- read.csv("data/tblAkv3x3.csv", header = FALSE)
N <- 3
#Introduzca la memoria, recuerde que la memoria minima debe permitir hacer una operacion,
# es decir tomar por lo menos un valor de la matriz y un valor del vector, y poder guardar
# el resultado.
#************************************************************************
memoria <- 5664
#************************************************************************
if (memoria > memory.limit()){
print("La maquina no posee tanta memoria, por lo tanto no se puede realizar las operaciones
con esta cantidad de memoria.")
}
#Minmemoria <- Una fila de la matriz  + Una columna de la matriz    + El maximo resultado de una multiplicacion n veces
minmemoria <- object.size(A[N,])*N + object.size(B[N,])*N + (object.size(max(A[,ncol(A)]) * max(B[,ncol(B)])))*N
memoria <- memlimit(memoria)
if (memoria < minmemoria){
print("No hay suficiente memoria para realizar una operacion")
}
#Llamo a producmv
resultadomm <- productmm(A, B, N, memoria)
cat("El resultado de A*B 3x3 con memoria es: " )
resultadomm
#Borro el archivo temporal.
unlink(paste(direccion,"/tmp/archivotemporal.csv", sep = ""))
source("src/productmm.R")
A <- read.csv("data/tblAkv3x3.csv", header = FALSE)
B <- read.csv("data/tblAkv3x3.csv", header = FALSE)
N <- 3
#Introduzca la memoria, recuerde que la memoria minima debe permitir hacer una operacion,
# es decir tomar por lo menos un valor de la matriz y un valor del vector, y poder guardar
# el resultado.
#************************************************************************
memoria <- 5664
#************************************************************************
if (memoria > memory.limit()){
print("La maquina no posee tanta memoria, por lo tanto no se puede realizar las operaciones
con esta cantidad de memoria.")
}
#Minmemoria <- Una fila de la matriz  + Una columna de la matriz    + El maximo resultado de una multiplicacion n veces
minmemoria <- object.size(A[N,])*N + object.size(B[N,])*N + (object.size(max(A[,ncol(A)]) * max(B[,ncol(B)])))*N
memoria <- memlimit(memoria)
if (memoria < minmemoria){
print("No hay suficiente memoria para realizar una operacion")
}
#Llamo a producmv
resultadomm <- productmm(A, B, N, memoria)
cat("El resultado de A*B 3x3 con memoria es: " )
resultadomm
#Borro el archivo temporal.
unlink(paste(direccion,"/tmp/archivotemporal.csv", sep = ""))
source("src/productmm.R")
A <- read.csv("data/tblAkv3x3.csv", header = FALSE)
B <- read.csv("data/tblAkv3x3.csv", header = FALSE)
N <- 3
#Introduzca la memoria, recuerde que la memoria minima debe permitir hacer una operacion,
# es decir tomar por lo menos un valor de la matriz y un valor del vector, y poder guardar
# el resultado.
#************************************************************************
memoria <- 5664
#************************************************************************
if (memoria > memory.limit()){
print("La maquina no posee tanta memoria, por lo tanto no se puede realizar las operaciones
con esta cantidad de memoria.")
}
#Minmemoria <- Una fila de la matriz  + Una columna de la matriz    + El maximo resultado de una multiplicacion n veces
minmemoria <- object.size(A[N,])*N + object.size(B[N,])*N + (object.size(max(A[,ncol(A)]) * max(B[,ncol(B)])))*N
memoria <- memlimit(memoria)
if (memoria < minmemoria){
print("No hay suficiente memoria para realizar una operacion")
}
#Llamo a producmv
resultadomm <- productmm(A, B, N, memoria)
cat("El resultado de A*B 3x3 con memoria es: " )
resultadomm
#Borro el archivo temporal.
unlink(paste(direccion,"/tmp/archivotemporal.csv", sep = ""))
source("src/productmm.R")
direccion <- "C:/Users/Eric/Desktop/MapReduce/multiplicacion-matriz-vector-matriz-matriz-con-mapreduce-grupo-hej"
source("src/productmm.R")
source("src/productmm.R")
unlink(paste(direccion,"/tmp/archivotemporal.csv", sep = ""))
A <- read.csv("data/tblAkv3x3.csv", header = FALSE)
B <- read.csv("data/tblAkv3x3.csv", header = FALSE)
N <- 3
#Introduzca la memoria, recuerde que la memoria minima debe permitir hacer una operacion,
# es decir tomar por lo menos un valor de la matriz y un valor del vector, y poder guardar
# el resultado.
#************************************************************************
memoria <- 5664
#************************************************************************
if (memoria > memory.limit()){
print("La maquina no posee tanta memoria, por lo tanto no se puede realizar las operaciones
con esta cantidad de memoria.")
}
#Minmemoria <- Una fila de la matriz  + Una columna de la matriz    + El maximo resultado de una multiplicacion n veces
minmemoria <- object.size(A[N,])*N + object.size(B[N,])*N + (object.size(max(A[,ncol(A)]) * max(B[,ncol(B)])))*N
memoria <- memlimit(memoria)
if (memoria < minmemoria){
print("No hay suficiente memoria para realizar una operacion")
}
#Llamo a producmv
resultadomm <- productmm(A, B, N, memoria)
cat("El resultado de A*B 3x3 con memoria es: " )
resultadomm
A
A[1:3,1]
A[1:3, ncol(A)]
source("src/productmm.R")
A <- read.csv("data/tblAkv3x3.csv", header = FALSE)
B <- read.csv("data/tblAkv3x3.csv", header = FALSE)
N <- 3
#Introduzca la memoria, recuerde que la memoria minima debe permitir hacer una operacion,
# es decir tomar por lo menos un valor de la matriz y un valor del vector, y poder guardar
# el resultado.
#************************************************************************
memoria <- 5664
#************************************************************************
if (memoria > memory.limit()){
print("La maquina no posee tanta memoria, por lo tanto no se puede realizar las operaciones
con esta cantidad de memoria.")
}
#Minmemoria <- Una fila de la matriz  + Una columna de la matriz    + El maximo resultado de una multiplicacion n veces
minmemoria <- object.size(A[N,])*N + object.size(B[N,])*N + (object.size(max(A[,ncol(A)]) * max(B[,ncol(B)])))*N
memoria <- memlimit(memoria)
if (memoria < minmemoria){
print("No hay suficiente memoria para realizar una operacion")
}
#Llamo a producmv
resultadomm <- productmm(A, B, N, memoria)
cat("El resultado de A*B 3x3 con memoria es: " )
resultadomm
#Borro el archivo temporal.
unlink(paste(direccion,"/tmp/archivotemporal.csv", sep = ""))
source("src/productmm.R")
A <- read.csv("data/tblAkv3x3.csv", header = FALSE)
B <- read.csv("data/tblAkv3x3.csv", header = FALSE)
N <- 3
#Introduzca la memoria, recuerde que la memoria minima debe permitir hacer una operacion,
# es decir tomar por lo menos un valor de la matriz y un valor del vector, y poder guardar
# el resultado.
#************************************************************************
memoria <- 5664
#************************************************************************
if (memoria > memory.limit()){
print("La maquina no posee tanta memoria, por lo tanto no se puede realizar las operaciones
con esta cantidad de memoria.")
}
#Minmemoria <- Una fila de la matriz  + Una columna de la matriz    + El maximo resultado de una multiplicacion n veces
minmemoria <- object.size(A[N,])*N + object.size(B[N,])*N + (object.size(max(A[,ncol(A)]) * max(B[,ncol(B)])))*N
memoria <- memlimit(memoria)
if (memoria < minmemoria){
print("No hay suficiente memoria para realizar una operacion")
}
#Llamo a producmv
resultadomm <- productmm(A, B, N, memoria)
cat("El resultado de A*B 3x3 con memoria es: " )
resultadomm
#Borro el archivo temporal.
unlink(paste(direccion,"/tmp/archivotemporal.csv", sep = ""))
source("src/productmm.R")
A <- read.csv("data/tblAkv3x3.csv", header = FALSE)
B <- read.csv("data/tblAkv3x3.csv", header = FALSE)
N <- 3
#Introduzca la memoria, recuerde que la memoria minima debe permitir hacer una operacion,
# es decir tomar por lo menos un valor de la matriz y un valor del vector, y poder guardar
# el resultado.
#************************************************************************
memoria <- 5664
#************************************************************************
if (memoria > memory.limit()){
print("La maquina no posee tanta memoria, por lo tanto no se puede realizar las operaciones
con esta cantidad de memoria.")
}
#Minmemoria <- Una fila de la matriz  + Una columna de la matriz    + El maximo resultado de una multiplicacion n veces
minmemoria <- object.size(A[N,])*N + object.size(B[N,])*N + (object.size(max(A[,ncol(A)]) * max(B[,ncol(B)])))*N
memoria <- memlimit(memoria)
if (memoria < minmemoria){
print("No hay suficiente memoria para realizar una operacion")
}
#Llamo a producmv
resultadomm <- productmm(A, B, N, memoria)
cat("El resultado de A*B 3x3 con memoria es: " )
resultadomm
A <- read.csv("data/tblAkv3x3.csv", header = FALSE)
B <- read.csv("data/tblAkv3x3.csv", header = FALSE)
N <- 3
#Introduzca la memoria, recuerde que la memoria minima debe permitir hacer una operacion,
# es decir tomar por lo menos un valor de la matriz y un valor del vector, y poder guardar
# el resultado.
#************************************************************************
memoria <- 5664
#************************************************************************
if (memoria > memory.limit()){
print("La maquina no posee tanta memoria, por lo tanto no se puede realizar las operaciones
con esta cantidad de memoria.")
}
#Minmemoria <- Una fila de la matriz  + Una columna de la matriz    + El maximo resultado de una multiplicacion n veces
minmemoria <- object.size(A[N,])*N + object.size(B[N,])*N + (object.size(max(A[,ncol(A)]) * max(B[,ncol(B)])))*N
memoria <- memlimit(memoria)
if (memoria < minmemoria){
print("No hay suficiente memoria para realizar una operacion")
}
#Llamo a producmv
resultadomm <- productmm(A, B, N, memoria)
cat("El resultado de A*B 3x3 con memoria es: " )
resultadomm
direccion <- "C:/Users/Eric/Desktop/MapReduce/multiplicacion-matriz-vector-matriz-matriz-con-mapreduce-grupo-hej"
setwd(direccion)
source("src/memlimit.R")
source("src/productmv.R")
source("src/productmm.R")
#source("src/productmvSINMEMORIA.R")
unlink(paste(direccion,"/tmp/archivotemporal.csv", sep = ""))
A <- read.csv("data/tblAkv3x3.csv", header = FALSE)
B <- read.csv("data/tblAkv3x3.csv", header = FALSE)
N <- 3
#Introduzca la memoria, recuerde que la memoria minima debe permitir hacer una operacion,
# es decir tomar por lo menos un valor de la matriz y un valor del vector, y poder guardar
# el resultado.
#************************************************************************
memoria <- 5664
#************************************************************************
if (memoria > memory.limit()){
print("La maquina no posee tanta memoria, por lo tanto no se puede realizar las operaciones
con esta cantidad de memoria.")
}
#Minmemoria <- Una fila de la matriz  + Una columna de la matriz    + El maximo resultado de una multiplicacion n veces
minmemoria <- object.size(A[N,])*N + object.size(B[N,])*N + (object.size(max(A[,ncol(A)]) * max(B[,ncol(B)])))*N
memoria <- memlimit(memoria)
if (memoria < minmemoria){
print("No hay suficiente memoria para realizar una operacion")
}
#Llamo a producmv
resultadomm <- productmm(A, B, N, memoria)
cat("El resultado de A*B 3x3 con memoria es: " )
resultadomm
#Borro el archivo temporal.
unlink(paste(direccion,"/tmp/archivotemporal.csv", sep = ""))
A
direccion <- "C:/Users/Eric/Desktop/MapReduce/multiplicacion-matriz-vector-matriz-matriz-con-mapreduce-grupo-hej"
setwd(direccion)
source("src/memlimit.R")
source("src/productmv.R")
source("src/productmm.R")
#source("src/productmvSINMEMORIA.R")
unlink(paste(direccion,"/tmp/archivotemporal.csv", sep = ""))
A <- read.csv("data/tblAkv3x3.csv", header = FALSE)
B <- read.csv("data/tblAkv3x3.csv", header = FALSE)
N <- 3
#Introduzca la memoria, recuerde que la memoria minima debe permitir hacer una operacion,
# es decir tomar por lo menos un valor de la matriz y un valor del vector, y poder guardar
# el resultado.
#************************************************************************
memoria <- 5664
#************************************************************************
if (memoria > memory.limit()){
print("La maquina no posee tanta memoria, por lo tanto no se puede realizar las operaciones
con esta cantidad de memoria.")
}
#Minmemoria <- Una fila de la matriz  + Una columna de la matriz    + El maximo resultado de una multiplicacion n veces
minmemoria <- object.size(A[N,])*N + object.size(B[N,])*N + (object.size(max(A[,ncol(A)]) * max(B[,ncol(B)])))*N
memoria <- memlimit(memoria)
if (memoria < minmemoria){
print("No hay suficiente memoria para realizar una operacion")
}
#Llamo a producmv
resultadomm <- productmm(A, B, N, memoria)
cat("El resultado de A*B 3x3 con memoria es: " )
resultadomm
A <- read.csv("data/tblAkv3x3.csv", header = FALSE)
B <- read.csv("data/tblAkv3x3.csv", header = FALSE)
N <- 3
print(i)
cont <- 1
i <- 1
j <- 1
for (k in 1:cont) {
W <- 0
for (h in i:((i+N)-1)) {
j <- W + j
resultado <- A[(j+k)-1, ncol(A)] * B[h, ncol(B)]
write.table(resultado, file = "tmp/archivotemporal.csv", row.names = FALSE,
col.names = FALSE, sep = ",", append = T)
W <- W + N
}
}
cont <- 1
i <- 2
j <- 4
for (k in 1:cont) {
W <- 0
for (h in i:((i+N)-1)) {
j <- W + j
resultado <- A[(j+k)-1, ncol(A)] * B[h, ncol(B)]
write.table(resultado, file = "tmp/archivotemporal.csv", row.names = FALSE,
col.names = FALSE, sep = ",", append = T)
W <- W + N
}
}
cont <- 1
i <- 3
j <- 7
for (k in 1:cont) {
W <- 0
for (h in i:((i+N)-1)) {
j <- W + j
resultado <- A[(j+k)-1, ncol(A)] * B[h, ncol(B)]
write.table(resultado, file = "tmp/archivotemporal.csv", row.names = FALSE,
col.names = FALSE, sep = ",", append = T)
W <- W + N
}
}
z <- read.csv("tmp/archivotemporal.csv", header = FALSE)
z
for (indice in 1:N) {
chunksF <- N
cont <- chunks(A, B, N, chunksF, indice)
}
chunks <- function(A, B, N, chunksF, indice){
#********************************************************
#Division de chunks utilizando la memoria.
#********************************************************
#tamres es el tamano necesario para guardar un resultado.
tamres <- (object.size(max(A[,ncol(A)]) * max(B[,ncol(B)])))*N
#tamcol es el size de un valor del vector.
tamcol <- object.size(B[N,])*N
#Acumula la cantidad de memoria que se puede utilizar
acum <- 0
#Cuenta cuantas operaciones se pueden hacer
cont <- 0
for (i in indice:((indice + chunksF)-1)) {
acum <- object.size(A[i,])*N  + tamres  + tamcol + acum
if (acum > memoria){
break
}
#Cuento cuantos valores  puedo utilizar.
cont <- cont + 1
}
return(cont)
}
for (indice in 1:N) {
chunksF <- N
cont <- chunks(A, B, N, chunksF, indice)
}
memoria <- 5664
for (indice in 1:N) {
chunksF <- N
cont <- chunks(A, B, N, chunksF, indice)
}
cont
A
